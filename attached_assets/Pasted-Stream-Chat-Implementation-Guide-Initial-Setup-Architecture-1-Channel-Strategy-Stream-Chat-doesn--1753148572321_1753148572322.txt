Stream Chat Implementation Guide
Initial Setup & Architecture
1. Channel Strategy
Stream Chat doesn't use "folders" - instead, use channel types and custom fields:
javascript// Create a custom channel type in Stream Dashboard first
// Channel type: "messaging" with these custom fields:
// - messageType: 'direct' | 'group'
// - isArchived: boolean
// - isDraft: boolean
2. Message Schema
javascript// When sending messages, include custom data
const message = {
  text: messageBody,
  attachments: [], // for file attachments
  custom: {
    subject: "Message Subject",
    isRead: false,
    isDraft: false,
    isDeleted: false, // soft delete
    recipients: ['user_id_1', 'user_id_2'], // for display purposes
    folder: 'inbox' // virtual folder for filtering
  }
};
Folder Implementation (Virtual Folders)
Since Stream doesn't have folders, create them client-side:
javascript// Inbox: Messages where you're a recipient
const inboxMessages = await channel.query({
  messages: {
    'custom.isDeleted': { $ne: true },
    'custom.isDraft': { $ne: true }
  }
}).filter(msg => msg.user.id !== currentUserId);

// Sent: Messages you sent
const sentMessages = await channel.query({
  messages: {
    user_id: currentUserId,
    'custom.isDeleted': { $ne: true },
    'custom.isDraft': { $ne: true }
  }
});

// Drafts: Unsent messages stored locally or in custom channel
const draftChannel = client.channel('messaging', `drafts-${userId}`);

// Trash: Soft-deleted messages
const trashedMessages = await channel.query({
  messages: {
    'custom.isDeleted': true
  }
});
Unread Count & Badges
javascript// Stream provides built-in unread counts
const { total_unread_count } = await client.getUnreadCount();

// Mark as read when opening message
await channel.markRead({ message_id: messageId });

// Listen for unread count changes
client.on('notification.mark_read', (event) => {
  updateUnreadBadge(event.total_unread_count);
});
Multi-Recipient Messaging
javascript// For group messages, create a channel with multiple members
const groupChannel = await client.channel('messaging', {
  members: ['user1', 'user2', 'user3'],
  name: 'Group Message Subject',
  custom: {
    messageType: 'group'
  }
}).create();

// For "email-style" where recipients don't see each other:
// Create separate 1:1 channels for each recipient
const sendToMultiple = async (senderID, recipientIDs, message) => {
  for (const recipientID of recipientIDs) {
    const channel = client.channel('messaging', {
      members: [senderID, recipientID]
    });
    await channel.sendMessage(message);
  }
};
Key Features Implementation
1. Compose New Message
javascriptconst composeMessage = async (recipients, subject, body) => {
  // Store draft first
  const draftChannel = client.channel('messaging', `drafts-${userId}`);
  const draftMessage = await draftChannel.sendMessage({
    text: body,
    custom: { subject, recipients, isDraft: true }
  });
  
  // When sending, create actual channels and delete draft
  // ... send logic
  await draftChannel.deleteMessage(draftMessage.id);
};
2. Reply Functionality
javascript// Stream has built-in threading
const replyToMessage = async (parentMessageId, replyText) => {
  await channel.sendMessage({
    text: replyText,
    parent_id: parentMessageId, // This creates a thread
    custom: { subject: `Re: ${originalSubject}` }
  });
};
3. Forward Functionality
javascriptconst forwardMessage = async (originalMessage, newRecipients) => {
  const forwardedMessage = {
    text: originalMessage.text,
    custom: {
      subject: `Fwd: ${originalMessage.custom.subject}`,
      forwardedFrom: originalMessage.user.id,
      originalMessageId: originalMessage.id
    }
  };
  // Send to new recipients using sendToMultiple logic
};
Real-time Updates
javascript// Listen for new messages
channel.on('message.new', (event) => {
  // Add to inbox if you're recipient
  if (event.message.user.id !== currentUserId) {
    addToInbox(event.message);
    incrementUnreadBadge();
  }
});

// Listen for message updates (read status)
channel.on('message.updated', (event) => {
  if (event.message.custom.isRead) {
    markAsReadInUI(event.message.id);
  }
});
Search Implementation
javascript// Stream provides powerful search
const { results } = await client.search(
  { type: 'messaging' },
  { text: { $autocomplete: searchTerm } },
  { limit: 20 }
);

// Or search in custom fields
const results = await client.search(
  { type: 'messaging' },
  { 'custom.subject': { $autocomplete: searchTerm } }
);
Critical Implementation Notes
1. State Management

Use React Query or similar for caching
Store draft messages locally (localStorage) as backup
Implement optimistic updates for better UX

2. Performance

Paginate message lists (Stream supports this)
Lazy load message bodies
Use Stream's state to avoid redundant API calls

3. Error Handling
javascript// Wrap all Stream operations
try {
  await channel.sendMessage(message);
} catch (error) {
  if (error.code === 4) { // Rate limit
    // Implement exponential backoff
  } else if (error.code === 16) { // Permission error
    // Handle unauthorized access
  }
  // Store failed message locally for retry
}
4. Missing Stream Features (Workarounds)

Folders: Use custom fields and client-side filtering
Drafts: Create a dedicated drafts channel per user
Bulk operations: Iterate through messages (respect rate limits)